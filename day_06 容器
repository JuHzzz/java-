一。 <java容器 基本原理>
  
    1.Collection： 一个独立元素的序列，这些元素都服从一条或多条规则。List必须按照插入顺序来保存元素，Set不允许有重复对象，Queue必须按照队列的规则来
    确定对象产生的顺序。
    2.Map ： 包含一组成对的对象，它的键和值都是对象，并且它们两个相互关联，允许通过键来查找值，也被称为关联数组。
    
    >
    
     Collection的构造器可以接受另一个Collection，用它来将自身初始化，因此可以使用Arrays.List()来为这个构造器产生输入。但是Collection.addAll()方法
     运行起来较快，还可以构建一个不包含元素的Collection；但是这个方法只能接受另一个Collection对象作为参数 ，因此他不如Arrays.List()或Collections.addAll()
     方法灵活。
     
    >
    
      Collection在每个槽中只能保存一个元素。此类容器包括：List，它以特定的顺序保存一组元素；Set，元素不能重复；Queue，只允许在容器的一段插入对象，另一端
      移除对象。
  
    >
     java提供了大量持有对象的方式：
      1.数组将数字与对象联系起来。他保存类型明确的对象，查询对象时，不需要对结果做类型转换，他可以是多维的，它可以保存基本类型的数据，但是一旦创建其容量不可变；
      2.Collection 保存单一元素，而Map保存相关联的键值对。有了java的泛型，我们就可以在创建容器的时候规定容器中存储对象的类型，当需要从容器中存取元素时，只需
      判断是否符合类型条件即可，不必做类型转换。各种Collection和Map都会在容器空间不足的时候，自动进行扩容。另外，容器中是不允许存放基本类型的对象的，但自动包装
      机制会仔细的执行基本类型到容器中包装类型的双向类型转换。
      3.像数组一样，List也建立数字索引与对象的关联，因此，数组与List都是排好序的容器，只不过List能够自动扩充容量。
      4.如果要进行大容量的随机访问存取，建议使用ArrayList容器；但如果需要频繁的做出插入和删除操作，推荐使用LinkedList容器。
      5.Map是一种将对象和对象关联起来的容器，它包含一组键值对，每一个键都有其自己的键值，两者是相互关联的，Map有两个常用的实现类，分别是HashMap和TreeMap，还有一个
      LinkedHashMap是HashMap的子类，HashMap可以快速访问；TreeMap使元素按“键”的顺序排列存放；LinkedHashMap在做到快速访问的同时还能按插入顺序保存元素。
      6.Set不接受重复元素。HashSet提供最快的查询速度，而TreeSet保持元素出于排序状态。LinkedHashSet以插入顺序保存元素。
      
 <迭代器>
 
      1.迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。因为创建它的代价较小，所以他是一种轻量级的对象。
      它也存在一些限制：
          --->1.使用方法iterator()要求容器返回一个Iterator。他将返回序列的第一个元素。
          --->2.使用next()获得序列中的下一个元素；
          --->3.使用hasNext()检查序列中是否还有元素；
          --->4.使用remove()将迭代器新返回的元素删除。(因此在使用remove（）之前要先使用next());
       *Iterator可以将遍历序列的操作与序列底层的结构分离
       
       2.ListIterator 是一个更加强大的Iterator的子类型，他只能用于各种List类的访问。尽管Iterator只能向前移动，但是ListIterator可以双向移动。
      
      
 二。<java 容器 深度解析>
 
 
