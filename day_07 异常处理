<异常概念>

    1.当我们在编程时，会时不时的遇到错误，这些错误有些可以在程序进行编译时就被发现，我们可以提前控制并处理；但还是会有一些我们无法提前预知的错误会发生，
    当这些错误或异常发生的时候，会使我们的程序运行不下去，因此就需要一种机制，能够对于程序运行期间发生的异常进行处理和控制，就产生了异常处理的机制，这种
    机制，可以使我们在编程时，将更多的精力放在对问题的解决上，而无需担心程序执行时意外停止，使得们可以把可能会出现的异常和对它们的处理分开处理，使得我们的
    程序具有更好地健壮性。
    
    2.当抛出异常之后，会有几件事情发生：
        --->1.首先发生异常时，会在堆上new一个异常的对象；
        --->2.然后当前的运行路径会被中止，并且弹出一个对当前对象异常的引用；
        --->3.异常处理机制接管程序，并开始寻找当前异常的处理程序，进行处理，将程序从错误状态中恢复。

    3.所有标准异常类都有两个构造器：无参的默认构造器；可以接收参数的，将异常信息放入对象的有参构造器。
    
<异常处理>

    1.异常处理程序通过一对try{}catch{};来捕获异常并可以进行小部分的处理；
    2.当使用第二种形式的异常处理形式时，每一对try{}catch{}都必须紧连着，异常处理程序必须紧跟在try{}块之后，当异常被抛出时，异常处理机制将搜寻参数与
    异常类型相匹配的第一个处理程序；然后进入catch{}字句执行，此时就认为异常得到了处理。
    3.异常处理有两种基本模型：①、终止模型：错误无法挽回，无法回去继续执行；②、恢复模型：发生异常后，对程序做出处理，查找出可能会使程序恢复继续执行的方法；、
    

<异常说明>

    1.在创建可能会发生异常的方法或者类的时候，要记得使用throws关键字显示的声明可能会发生的异常；
    2.如果没有声明，当程序编译后如果产生异常，编译器会提醒：要处理这个异常还是声明。
    3.预先声明可能会发生的异常的话，会为异常先占个位子，以后就可以抛出已有的异常而不用修改代码（抽象类和接口中很常见）
    
<栈轨迹>

    1.栈是一种特殊的存储结构，在内存中它占用一片连续的存储空间，它是一种特殊的线性表，只允许在一端进行插入删除操作，把这一端称为栈顶，另一端称为栈底，在
    这种结构中，向栈中插入元素称为压栈或入栈，删除元素称为出栈或弹栈；它是一种“先入后出”的存储结构。
    2.在异常处理中，有一种printStackTrack()方法，这个方法将返回一个由栈轨迹中的元素所组成的数组，其中每一个元素都是栈中的一帧；（元素0是栈顶元素，并且是
    调用序列中的最后一个方法调用，与之相对应的另一端是栈底元素，它是调用序列中的第一个方法调用）
    
<重抛异常>

    1.在try{}catch{}中，当我们通过catch{}子句捕获异常后，有时候根据需要会把异常重新抛出，这时异常会被交由他的上一级异常处理程序进行处理，这时同一个try{}块
    之后的后续catch{}子句将被忽略。此外，异常对象中的所有信息都将保留，他的上一级环境中就可以获取到这个异常中的所有信息从而进行处理了；
    2.如果仅仅只是把异常抛出，那么printStackTrace()显示的将是原来捕获异常时异常的信息，而非更新之后的异常信息，如果需要将异常信息进行更改时候，我们通常
    使用fillInStackTrace()方法来返回一个Throwable对象，它是通过调用当前栈信息填入原来异常信息的引用所指的对象儿建立的。
    
 <异常链>
 
    1.当我们捕获一个异常之后，想要重抛异常，异常信息更新抛出之后，我们还想保留之前的那个异常的信息，这被称为异常链；
    2.通常的做法是使用一个因由对象作为参数，用来表示原有异常，这样通过把原有异常当做参数传递给新的异常对象，使得即使在当前位置抛出异常，我们也可以凭借
    这个参数（因由对象）找到异常最初抛出的位置(Throwable的Exception，Error，RuntimeException提供了这个支持因由对象的构造器)；
    3.我们不应把java的异常处理机制当做是一种单一用途的工具，的确，它在我们程序代码控制之外可能会产生的错误上提供了强有力的处理机制；但在很多由于编译期间
    出现的突发事件而导致的异常（编译期间无法检测到的错误）也有很强大的处理能力。
    
 <finally子句>
    
    1.当要把内存之外的资源释放时，就要使用finally子句了，它可以将垃圾处理回收机制能力之外的系统资源加以释放。
    
 <异常限制>
 
    1.当我们在抛出异常时，通常会显示的在类，类中成员方法之后声明可能会抛出的异常；当这个类被产生派生类时，派生类中覆盖的基类成员方法就可以不再次显示的声明那些
    异常了，但我们会严格限制派生类中不可以产生其基类中声明的异常之外的其他异常，这么做保证了继承的合理实现；
    2.但有一个特殊的，就是异常限制对构造器不起作用，因为我们的构造器所在的类会被以各种样式调用或实现，但派生类的构造器的异常声明必须包含其基类的异常声明；
    3.异常产生时，派生类的构造器不能捕获其基类构造器抛出的异常；
    4.通过强制派生类遵守基类的异常说明，使对象的可替换性得到了保证；
    **方法类型：由方法名字和参数类型构成
    **重载方法：基于变量个数，变量类型
    5.在继承过程中，派生类必须严格遵守基类的异常说明；但异常说明并不属于方法类型，所以我们不能基于异常说明来重载方法；
   
<构造器>
    
    1.当我们创建对象时，对通过这个对象所指向的类的构造器类完成对对象的创建，如果在调用构造器进行执行的过程中，出现了异常，而后使程序无法进行下去，在此之后，
    还要对资源进行释放，而因为此时对象的部分功能还没有执行完毕，就出现了逻辑上的错误；
    2.对于在构造阶段中可能抛出的异常，我们采用嵌套的try{}catch{}来预防逻辑上错误的发生。
    
 <异常匹配>
    
    1.抛出异常的时候，异常处理系统会按照程序的编写顺序找出“最近”的异常处理程序，找到匹配的异常处理程序后，就认为这个异常得到了处理，然后就不再继续查找；
    2.异常处理的一个重要目标就是把可能会发生异常的地点和异常的处理分离开；
    
 <异常使用指南>
    
    1.在恰当的级别处理问题（当知道如何处理异常时再捕获异常）；
    2.解决问题的并且重新调用产生异常的方法；
    3.进行少许修补，然后绕过异常发生的地方继续执行；
    4.用别的数据进行计算，以代替方法预计会返回的值；
    5.在当前环境下把能做的的事情尽量做完，然后把不同的或者相同的异常抛给更高层；
    6.终止程序；
    7.进行简化；
    8.让类库和程序更加安全。
    
    
    
    ------以上均为个人的理解，如果有误，烦请各位指正，共同努力进步-------
 
    
    
    
    
    
    
    
    
    
